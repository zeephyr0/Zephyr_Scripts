from telethon import TelegramClient, sync
from telethon import events, utils
from telethon.tl.functions.messages import GetDialogsRequest
from telethon.tl.functions.messages import SendMessageRequest
from telethon.tl.types import InputPeerEmpty, PeerUser, PeerChat, PeerChannel
from telethon.errors import FloodWaitError
from telethon.errors import SessionPasswordNeededError
import datetime
import requests
import time
import random
import tracemalloc
import asyncio
import concurrent.futures

# –î–∞–Ω–Ω—ã–µ –∞–∫–∫–∞—É–Ω—Ç–æ–≤
api_id001 = '12588062'
api_hash001 = 'd0f061c565991d6ed274285c0d032f7a'
phone001 = '+79816661471'
cloud_password1 = '2303'

# –°–æ–∑–¥–∞–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç–æ–≤ 
client001 = TelegramClient('session001', api_id001, api_hash001)
# –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è
client001.connect()
if not client001.is_user_authorized():
    client001.send_code_request(phone001)
    try:
        client001.sign_in(phone001, input('Session-001 –í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è: '), password=cloud_password1)
    except SessionPasswordNeededError:
        client001.sign_in(password=cloud_password1)

# –í—Ä–µ–º—è –∑–∞–ø—É—Å–∫–∞ —Å–∫—Ä–∏–ø—Ç–∞
start_time = datetime.datetime.now()

async def send_message(client, mine_evo, message):
    try:
        await client.send_message(mine_evo, message)
    except FloodWaitError as e:
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–∫–∏ FloodWaitError
        print(f"–û—à–∏–±–∫–∞ FloodWaitError –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞ {client}: {e}")
        clients1.disconnect(client)
    except ValueError as e:
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–∫–∏, –µ—Å–ª–∏ –∫–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –∞–∫–∫–∞—É–Ω—Ç—É
        print(f"–û—à–∏–±–∫–∞: {e} –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞ {client}")
        clients1.disconnect(client)
    except ConnectionError:
        print('–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è. –ü–æ–≤—Ç–æ—Ä–Ω–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...')
        await asyncio.sleep(15)  # –ñ–¥–µ–º 5 —Å–µ–∫—É–Ω–¥ –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–æ–π
    except KeyboardInterrupt:
        pass
    except Exception as e:
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥—Ä—É–≥–∏—Ö –∏—Å–∫–ª—é—á–µ–Ω–∏–π
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞ {client}: {e}")

@client001.on(events.NewMessage(pattern='v.off'))
async def stop_sending_messages(event):
    global automatic_mode
    automatic_mode = True
    await event.message.edit('‚ùå –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è –≤—ã–∫–ª—é—á–µ–Ω–∞')

@client001.on(events.NewMessage(pattern='v.on'))
async def start_sending_messages(event):
    global automatic_mode
    automatic_mode = False
    await event.message.edit('‚úÖ –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è –≤–∫–ª—é—á–µ–Ω–∞')

@client001.on(events.NewMessage(pattern='m.send'))
async def send_multiple_messages1(event):
    global count1
    global automatic_mode
    chat_id = vikings 
    if stop_sending1:
        await asyncio.sleep(2) 
        await event.message.edit('‚ò†Ô∏è–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –Ω–∞—á–∞—Ç—å –∫–æ–ø–∞—Ç—å\n–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –≤—ã–∫–ª—é—á–µ–Ω–∞')
    else:
        await asyncio.sleep(2)
        await event.message.edit('üí¢–ù–∞—á–∏–Ω–∞–µ–º –∫–æ–ø–∞—Ç—å')
    while not stop_sending1:
        coroutines = []
        for client in clients1:
            coroutines.append(send_message(client, chat_id, '–∫–æ–ø'))
        await asyncio.gather(*coroutines)
        await asyncio.sleep(2)
        count1 += 29
        cycles1 += 1
        clients1 = [client for client in clients1 if client.is_connected()]

