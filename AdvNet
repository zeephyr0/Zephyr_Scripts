#boo


import random
import time 
from telethon.sync import TelegramClient, events
from telethon.tl.functions.channels import JoinChannelRequest
chat_usernames = ['username1', 'username2', 'username3']  # Список юзернеймов чатов
messages = ['Message 1', 'Message 2', 'Message 3']  # Список сообщений для отправки
count = 0  # Переменная для отслеживания количества отправленных сообщений
# Функция для проверки наличия вашего имени в тегах сообщения и призыва к подписке
def has_my_username_and_subscription_request(message, my_username):
    return '@' + my_username.lower() in message.raw_text.lower() and ('подпишитесь на канал' in message.text.lower() or 'подписаться на' in message.text.lower())
# Функция для отправки сообщений
async def send_multiple_messages(client, my_username):
    global count  # Объявляем переменную глобальной для отслеживания значения через вызовы функций
    
    # Подписываемся на каналы или группы из списка
    for chat_username in chat_usernames:
        try:
            chat = await client.get_entity(chat_username)
            if chat.megagroup:
                if not chat.username:
                    continue
                if not await client.is_chat_subscribed(chat.username):
                    await client(JoinChannelRequest(chat.username))
        except ValueError:
            continue
        except Exception as e:
            continue
    
    # Бесконечный цикл отправки сообщений
    while True:
        # Выбираем случайный чат и сообщение из списков
        chat_username = random.choice(chat_usernames)
        message = random.choice(messages)
        
        try:
            # Отправка сообщений
            await client.send_message(chat_username, message)
            count += 1  # Увеличиваем счетчик сообщений
            time.sleep(77);
# Инициализация клиентов
api_id_1 = 'YOUR_API_ID_1'
api_hash_1 = 'YOUR_API_HASH_1'
api_id_2 = 'YOUR_API_ID_2'
api_hash_2 = 'YOUR_API_HASH_2'

client1 = TelegramClient('session1', api_id_1, api_hash_1)
client2 = TelegramClient('session2', api_id_2, api_hash_2)

# Объявление функций обработчиков событий для каждого клиента
@events.register(events.NewMessage(pattern='/send_adv'))
async def send_multiple_messages_handler(event):
    await send_multiple_messages(event.client, event.client.get_me().username)
@events.register(events.NewMessage(incoming=True))
async def handle_incoming_message_handler(event):
    if has_my_username_and_subscription_request(event.message, event.client.get_me().username):
        # Вытаскиваем имя канала из сообщения и подписываемся на него
        channel_username = event.message.text.split(' ')[-1]
        try:
            channel = await event.client.get_entity(channel_username)
            if not await event.client.is_chat_subscribed(channel.username):
                await event.client(JoinChannelRequest(channel.username))
        except Exception as e:
            continue
# Запуск клиентов
with client1, client2:
    client1.add_event_handler(send_multiple_messages_handler)
    client1.add_event_handler(handle_incoming_message_handler)
    client2.add_event_handler(send_multiple_messages_handler)
    client2.add_event_handler(handle_incoming_message_handler)
    
    client1.run_until_disconnected()
    client2.run_until_disconnected()
