# coded by DEM
# good luck =]

from telethon import TelegramClient, sync
from telethon import events, utils
from telethon.tl.functions.messages import GetDialogsRequest
from telethon.tl.functions.messages import SendMessageRequest
from telethon.tl.types import InputPeerEmpty, PeerUser, PeerChat, PeerChannel
from telethon.errors import FloodWaitError
from telethon.errors import SessionPasswordNeededError
import datetime
import requests
import time
import random
import tracemalloc
import asyncio
import concurrent.futures
import json

# Данные аккаунтов
api_id001 = '12588062'
api_hash001 = 'd0f061c565991d6ed274285c0d032f7a'
phone001 = '+79816661471'

api_id002 = '13123883'
api_hash002 = 'f1fab12098570c2bf8848ad6ea23c62f'
phone002 = '+79676939873'

api_id003 = '19334807'
api_hash003 = '4b4edde7a9d46172399f0ac4cb98ae63'
phone003 = '+79842549006'

api_id004 = '16839412'
api_hash004 = 'aaa86871e0831e2ef1c9df22b921c9d4'
phone004 = '+79386950114'

api_id005 = '19179697'
api_hash005 = 'dd96018b9f53d55342f0c2c754c4fb29'
phone005 = '+79697678142'

api_id006 = '10904880'
api_hash006 = '0bce5ceebd00a5fe38dff632595b0bad'
phone006 = '+79587314180'

api_id008 = '23683219'
api_hash008 = '3712b06daec849ace954b67a522acb63'
phone008 = '+996999899010'

api_id009 = '26344028'
api_hash009 = 'aa920e0ab554994282bddfae8e9743e1'
phone009 = '+66644508357'

api_id010 = '24391372'
api_hash010 = 'f91208774fb18619d661aa988357327d'
phone010 = '+8801929321074'

api_id011 = '27999436'
api_hash011 = 'a762c27366b49c72c58cf0f265df61bc'
phone011 = '+996504072710'

api_id012 = '28054215'
api_hash012 = 'dca1c54af532f7dc0df4509bb5cd06fc'
phone012 = '+79016810191'

api_id013 = '20880148'
api_hash013 = '4cefa3607decdacf8995fa4faac6d9c0'
phone013 = '+79199250579'

api_id014 = '20074210'
api_hash014 = '40bf0e5e8441de28f0e30ef64190725b'
phone014 = '+79507244663'

api_id015 = '21931735'
api_hash015 = '9b2e64e80a51e048e4f5062772b5ab7f'
phone015 = '+380933888084'

api_id016 = '29141499'
api_hash016 = '77b4d4c1b20f95d8a09b05a1c5f67578'
phone016 = '+79159670843'

api_id017 = '20205793'
api_hash017 = '537c5d400f59a6629e4fa788fc135394'
phone017 = '+79494496325'

api_id019 = '20242585'
api_hash019 = '77312de9aab579af857c5d2fdb4e1d64'
phone019 = '+447424459503'

api_id020 = '27847181'
api_hash020 = 'd8bb609f8707d05ccd4050077bc2e51d'
phone020 = '+40701114055'

api_id021 = '26002707'
api_hash021 = 'a1f640a3b304457b1a964a2adc98b86a'
phone021 = '+40701114412'

api_id022 = '26177379'
api_hash022 = '079dafea2a2f15cc9c93baccae420765'
phone022 = '+40701114425'

api_id023 = '26199478'
api_hash023 = 'f18d94ee8a35da4dff4d591d0aaa3d28'
phone023 = '+40701114729'

api_id024 = '28645267'
api_hash024 = '9bb99e599cd7d22813f841c7a7ce47c6'
phone024 = '+40701131736'

api_id025 = '20410656'
api_hash025 = '7f48793a7737fe3a910874c38a5f6e21'
phone025 = '+60149256978'

api_id026 = '24106632'
api_hash026 = '65093abacde2ca064ce8802c84863fec'
phone026 = '+447771411600'

api_id027 = '22353684'
api_hash027 = '98cf980e06b08c566679c9e17b317a41'
phone027 = '+447983221564'

api_id028 = '28254953'
api_hash028 = '85a1580311447eaec43f26c0c12e7cda'
phone028 = '+447405618130'

api_id01 = '29017932'
api_hash01 = '24ed16f256156d9c2562103ff8b9ca13'
phone01 = '+79783210112'

api_id02 = '28598285'
api_hash02 = '01cb9ab33587a314e3b6bfeab6d91e6e'
phone02 = '+79787917812'

api_id03 = '20405618'
api_hash03 = '88510a339fb00837a920a82a34d443a5'
phone03 = '+14638009973'

api_id04 = '20253928'
api_hash04 = 'b6a31ca946b72d981c04f0b306c6de96'
phone04 = '+40701162108'

cloud_password1 = '2303'
cloud_password2 = 'rein'

# Создание клиентов 
client001 = TelegramClient('session001', api_id001, api_hash001)
client002 = TelegramClient('session002', api_id002, api_hash002)
client003 = TelegramClient('session003', api_id003, api_hash003)
client004 = TelegramClient('session004', api_id004, api_hash004)
client005 = TelegramClient('session005', api_id005, api_hash005)
client006 = TelegramClient('session006', api_id006, api_hash006)
client008 = TelegramClient('session008', api_id008, api_hash008)
client009 = TelegramClient('session009', api_id009, api_hash009)
client010 = TelegramClient('session010', api_id010, api_hash010)
client011 = TelegramClient('session011', api_id011, api_hash011)
client012 = TelegramClient('session012', api_id012, api_hash012)
client013 = TelegramClient('session013', api_id013, api_hash013)
client014 = TelegramClient('session014', api_id014, api_hash014)
client015 = TelegramClient('session015', api_id015, api_hash015)
client016 = TelegramClient('session016', api_id016, api_hash016)
client017 = TelegramClient('session017', api_id017, api_hash017)
client019 = TelegramClient('session019', api_id019, api_hash019)
client020 = TelegramClient('session020', api_id020, api_hash020)
client021 = TelegramClient('session021', api_id021, api_hash021)
client022 = TelegramClient('session022', api_id022, api_hash022)
client023 = TelegramClient('session023', api_id023, api_hash023)
client024 = TelegramClient('session024', api_id024, api_hash024)
client025 = TelegramClient('session025', api_id025, api_hash025)
client026 = TelegramClient('session026', api_id026, api_hash026)
client027 = TelegramClient('session027', api_id027, api_hash027)
client028 = TelegramClient('session028', api_id028, api_hash028)
client01 = TelegramClient('session01', api_id01, api_hash01)
client02 = TelegramClient('session02', api_id02, api_hash02)
client03 = TelegramClient('session03', api_id03, api_hash03)
client04 = TelegramClient('session04', api_id04, api_hash04)

# Время запуска скрипта
start_time = datetime.datetime.now()

# Авторизация
clients1 = [client001, client002, client003, client004, client005, client006, client008, client009, client010, client011, client012, client013, client014, client015, client016, client017, client019, client020, client021, client022, client023, client024, client025, client027, client028]
clients2 = [client01, client02, client03, client04]
clients3 = clients1 + clients2
# Авторизация
client001.connect()
if not client001.is_user_authorized():
    client001.send_code_request(phone001)
    try:
        client001.sign_in(phone001, input('Session-001 Введите код подтверждения: '), password=cloud_password1)
    except SessionPasswordNeededError:
        client001.sign_in(password=cloud_password1)

client002.connect()
if not client002.is_user_authorized():
    client002.send_code_request(phone002)
    try:
        client002.sign_in(phone002, input('Session-002 Введите код подтверждения: '), password=cloud_password1)
    except SessionPasswordNeededError:
        client002.sign_in(password=cloud_password1)

client003.connect()
if not client003.is_user_authorized():
    client003.send_code_request(phone003)
    try:
        client003.sign_in(phone003, input('Session-003 Введите код подтверждения: '), password=cloud_password1)
    except SessionPasswordNeededError:
        client003.sign_in(password=cloud_password1)

client004.connect()
if not client004.is_user_authorized():
    client004.send_code_request(phone004)
    try:
        client004.sign_in(phone004, input('Session-004 Введите код подтверждения: '), password=cloud_password1)
    except SessionPasswordNeededError:
        client004.sign_in(password=cloud_password1)

client005.connect()
if not client005.is_user_authorized():
    client005.send_code_request(phone005)
    try:
        client005.sign_in(phone005, input('Session-005 Введите код подтверждения: '), password=cloud_password1)
    except SessionPasswordNeededError:
        client005.sign_in(password=cloud_password1)

client006.connect()
if not client006.is_user_authorized():
    client006.send_code_request(phone006)
    try:
        client006.sign_in(phone006, input('Session-006 Введите код подтверждения: '), password=cloud_password1)
    except SessionPasswordNeededError:
        client006.sign_in(password=cloud_password1)

client008.connect()
if not client008.is_user_authorized():
    client008.send_code_request(phone008)
    try:
        client008.sign_in(phone008, input('Session-008 Введите код подтверждения: '), password=cloud_password1)
    except SessionPasswordNeededError:
        client008.sign_in(password=cloud_password1)

client009.connect()
if not client009.is_user_authorized():
    client009.send_code_request(phone009)
    try:
        client009.sign_in(phone009, input('Session-009 Введите код подтверждения: '), password=cloud_password1)
    except SessionPasswordNeededError:
        client009.sign_in(password=cloud_password1)

client010.connect()
if not client010.is_user_authorized():
    client010.send_code_request(phone010)
    try:
        client010.sign_in(phone010, input('Session-010 Введите код подтверждения: '), password=cloud_password1)
    except SessionPasswordNeededError:
        client010.sign_in(password=cloud_password1)

client011.connect()
if not client011.is_user_authorized():
    client011.send_code_request(phone011)
    try:
        client011.sign_in(phone011, input('Session-011 Введите код подтверждения: '), password=cloud_password1)
    except SessionPasswordNeededError:
        client011.sign_in(password=cloud_password1)

client012.connect()
if not client012.is_user_authorized():
    client012.send_code_request(phone012)
    try:
        client012.sign_in(phone012, input('Session-012 Введите код подтверждения: '), password=cloud_password1)
    except SessionPasswordNeededError:
        client012.sign_in(password=cloud_password1)

client013.connect()
if not client013.is_user_authorized():
    client013.send_code_request(phone013)
    try:
        client013.sign_in(phone013, input('Session-013 Введите код подтверждения: '), password=cloud_password1)
    except SessionPasswordNeededError:
        client013.sign_in(password=cloud_password1)

client014.connect()
if not client014.is_user_authorized():
    client014.send_code_request(phone014)
    try:
        client014.sign_in(phone014, input('Session-014 Введите код подтверждения: '), password=cloud_password1)
    except SessionPasswordNeededError:
        client014.sign_in(password=cloud_password1)

client015.connect()
if not client015.is_user_authorized():
    client015.send_code_request(phone015)
    try:
        client015.sign_in(phone015, input('Session-015 Введите код подтверждения: '), password=cloud_password1)
    except SessionPasswordNeededError:
        client015.sign_in(password=cloud_password1)

client016.connect()
if not client016.is_user_authorized():
    client016.send_code_request(phone016)
    try:
        client016.sign_in(phone016, input('Session-016 Введите код подтверждения: '), password=cloud_password1)
    except SessionPasswordNeededError:
        client016.sign_in(password=cloud_password1)

client017.connect()
if not client017.is_user_authorized():
    client017.send_code_request(phone017)
    try:
        client017.sign_in(phone017, input('Session-017 Введите код подтверждения: '), password=cloud_password1)
    except SessionPasswordNeededError:
        client017.sign_in(password=cloud_password1)

client019.connect()
if not client019.is_user_authorized():
    client019.send_code_request(phone019)
    try:
        client019.sign_in(phone019, input('Session-019 Введите код подтверждения: '), password=cloud_password1)
    except SessionPasswordNeededError:
        client019.sign_in(password=cloud_password1)

client020.connect()
if not client020.is_user_authorized():
    client020.send_code_request(phone020)
    try:
        client020.sign_in(phone020, input('Session-020 Введите код подтверждения: '), password=cloud_password1)
    except SessionPasswordNeededError:
        client020.sign_in(password=cloud_password1)

client021.connect()
if not client021.is_user_authorized():
    client021.send_code_request(phone021)
    try:
        client021.sign_in(phone021, input('Session-021 Введите код подтверждения: '), password=cloud_password1)
    except SessionPasswordNeededError:
        client021.sign_in(password=cloud_password1)

client022.connect()
if not client022.is_user_authorized():
    client022.send_code_request(phone022)
    try:
        client022.sign_in(phone022, input('Session-022 Введите код подтверждения: '), password=cloud_password1)
    except SessionPasswordNeededError:
        client022.sign_in(password=cloud_password1)

client023.connect()
if not client023.is_user_authorized():
    client023.send_code_request(phone023)
    try:
        client023.sign_in(phone023, input('Session-023 Введите код подтверждения: '), password=cloud_password1)
    except SessionPasswordNeededError:
        client023.sign_in(password=cloud_password1)

client024.connect()
if not client024.is_user_authorized():
    client024.send_code_request(phone024)
    try:
        client024.sign_in(phone024, input('Session-024 Введите код подтверждения: '), password=cloud_password1)
    except SessionPasswordNeededError:
        client024.sign_in(password=cloud_password1)

client025.connect()
if not client025.is_user_authorized():
    client025.send_code_request(phone025)
    try:
        client025.sign_in(phone025, input('Session-025 Введите код подтверждения: '), password=cloud_password1)
    except SessionPasswordNeededError:
        client025.sign_in(password=cloud_password1)

client026.connect()
if not client026.is_user_authorized():
    client026.send_code_request(phone026)
    try:
        client026.sign_in(phone026, input('Session-026 Введите код подтверждения: '), password=cloud_password1)
    except SessionPasswordNeededError:
        client026.sign_in(password=cloud_password1)

client027.connect()
if not client027.is_user_authorized():
    client027.send_code_request(phone027)
    try:
        client027.sign_in(phone027, input('Session-027 Введите код подтверждения: '), password=cloud_password1)
    except SessionPasswordNeededError:
        client027.sign_in(password=cloud_password1)

client028.connect()
if not client028.is_user_authorized():
    client028.send_code_request(phone028)
    try:
        client028.sign_in(phone028, input('Session-028 Введите код подтверждения: '), password=cloud_password1)
    except SessionPasswordNeededError:
        client028.sign_in(password=cloud_password1)


for client in clients1:
    client.start()
    print('Клиенты успешно запущены!')

# Адресы
mineEvo_channel = '@mine_evo_news'
my_channel = '@Demo_minePromo'
mine_evo = '@mine_evo_bot'
twins_group = '@twinsFarm_byDem'

count1 = 0
cycles1 = 0
count2 = 0
cycles2 = 0
stop_sending1 = True
stop_sending2 = True
stop_sending3 = False
stop_sending4 = False
player_names1 = ['Gnom1', 'Gnom2', 'Gnom3', 'Gnom4', 'Gnom5', 'Gnom6', 'Gnom7', 'Gnom8', 'Gnom13', 'Gnom14', 'Gnom15', 'Gnom16', 'Gnom17', 'Gnom18', 'Gnom19', 'Gnom20', 'Gnom21', 'Gnom22', 'Gnom23', 'Gnom24', 'Gnom25', 'Gnom26', 'Gnom27', 'Gnom28', 'Gnom28', 'Gnom29', 'Gnom30', 'Gnom31', 'Gnom32', 'Gnom33', 'Gnom34', 'Gnom35', 'Gnom36', 'Gnom37', 'Gnom38', 'Gnom39', 'Gnom40', 'Gnom40', 'Gnom42', 'Gnom43']
player_names2 = ['Тоука','Bisbaka', 'Soufle', 'Unier']

async def send_message(client, mine_evo, message):
    try:
        await client.send_message(mine_evo, message)
    except FloodWaitError as e:
        # Обработка ошибки FloodWaitError
        print(f"Ошибка FloodWaitError для клиента {client}: {e}")
        clients1.disconnect(client)
    except ValueError as e:
        # Обработка ошибки, если клиент не найден или нет доступа к аккаунту
        print(f"Ошибка: {e} для клиента {client}")
        clients1.disconnect(client)
    except ConnectionError:
        print('Ошибка подключения. Повторное подключение...')
        await asyncio.sleep(15)  # Ждем 5 секунд перед повторной попыткой
    except KeyboardInterrupt:
        pass
    except Exception as e:
        # Обработка других исключений
        print(f"Ошибка при отправке сообщения для клиента {client}: {e}")

@client001.on(events.NewMessage(pattern='m.off'))
async def stop_sending_messages(event):
    global stop_sending1
    stop_sending1 = True
    await event.message.edit('❌Отправка сообщений выключена')

@client001.on(events.NewMessage(pattern='m.on'))
async def start_sending_messages(event):
    global stop_sending1
    stop_sending1 = False
    await event.message.edit('✅Отправка сообщений включена')

@client01.on(events.NewMessage(pattern='m.off'))
async def stop_sending_messages(event):
    global stop_sending2
    stop_sending2 = True
    await event.message.edit('❌Отправка сообщений выключена')

@client01.on(events.NewMessage(pattern='m.on'))
async def start_sending_messages(event):
    global stop_sending2
    stop_sending2 = False
    await event.message.edit('✅Отправка сообщений включена')

@client001.on(events.NewMessage(pattern='m.send'))
async def send_multiple_messages1(event):
    global count1
    global cycles1
    global clients1  # Declare clients1 as a global variable
    await event.message.edit('Пробуем копать...')
    chat_id = mine_evo
    if stop_sending1:
        await asyncio.sleep(2) 
        await event.message.edit('☠️Невозможно начать копать\nОтправка сообщений выключена')
    else:
        await asyncio.sleep(2)
        await event.message.edit('💢Начинаем копать')
    while not stop_sending1:
        coroutines = []
        for client in clients1:
            coroutines.append(send_message(client, chat_id, 'коп'))
        await asyncio.gather(*coroutines)
        await asyncio.sleep(2)
        count1 += 29
        cycles1 += 1
        clients1 = [client for client in clients1 if client.is_connected()]

        if not clients1:
            print("Все клиенты потеряли соединение.")
            break

@client01.on(events.NewMessage(pattern='m.send'))
async def send_multiple_messages2(event):
    global count2
    global cycles2
    await event.message.edit('Пробуем копать...')
    # Определение id чата
    chat_id = mine_evo
    if stop_sending2:
        await asyncio.sleep(2)
        await event.message.edit('☠️Невозможно начать копать\nОтправка сообщений выключена')
    else:
        await asyncio.sleep(2)
        await event.message.edit('💢Начинаем копать')
    while not stop_sending2:  # Проверка флага перед каждой итерацией цикла
        # Создание списка корутин для каждого клиента
        coroutines = []
        for client in clients2:
            coroutines.append(send_message(client, chat_id, 'коп'))
        # Одновременное выполнение всех корутин
        await asyncio.gather(*coroutines)
        # Задержка
        await asyncio.sleep(2)
        count2 += 4
        cycles2 += 1

@client001.on(events.NewMessage(pattern='gl.send'))
async def send_multiple_messages3(event):
    global count2
    global cycles2
    await event.message.edit('Пробуем копать...')
    # Определение id чата
    chat_id = mine_evo
    if stop_sending3:
        await asyncio.sleep(2)
        await event.message.edit('☠️Невозможно начать копать\nОтправка сообщений выключена')
    else:
        await asyncio.sleep(2)
        await event.message.edit('💢Начинаем копать')
    while not stop_sending3:  # Проверка флага перед каждой итерацией цикла
        # Создание списка корутин для каждого клиента
        coroutines = []
        for client in clients2:
            coroutines.append(send_message(client, chat_id, 'коп'))
        # Одновременное выполнение всех корутин
        await asyncio.gather(*coroutines)
        # Задержка
        await asyncio.sleep(2)
        count1 += 4
        cycles1 += 1

@client01.on(events.NewMessage(pattern='gl.send'))
async def send_multiple_messages4(event):
    global count1
    global cycles1
    await event.message.edit('Пробуем копать...')
    # Определение id чата
    chat_id = mine_evo
    if stop_sending3:
        await asyncio.sleep(2)
        await event.message.edit('☠️Невозможно начать копать\nОтправка сообщений выключена')
    else:
        await asyncio.sleep(2)
        await event.message.edit('💢Начинаем копать')
    while not stop_sending3:  # Проверка флага перед каждой итерацией цикла
        # Создание списка корутин для каждого клиента
        coroutines = []
        for client in clients1:
            coroutines.append(send_message(client, chat_id, 'коп'))
        # Одновременное выполнение всех корутин
        await asyncio.gather(*coroutines)
        # Задержка
        await asyncio.sleep(2)
        count1 += 29
        cycles1 += 1


# Модуль для проверки кейсов
@client001.on(events.NewMessage(pattern='m.cases'))
async def cases_info1(event):
    # Текст для отправки сообщения 
    message = 'кейсы'
    for client in clients1:
        await asyncio.sleep(2)
        await client(SendMessageRequest(mine_evo, message))

# Модуль для проверки кейсов
@client01.on(events.NewMessage(pattern='m.cases'))
async def cases_info2(event):
    # Текст для отправки сообщения 
    message = 'кейсы'
    for client in clients2:
        await asyncio.sleep(2)
        await client(SendMessageRequest(mine_evo, message))


# Отправка кейсов

# Список кейсов
cases_list = {
    "✉": "кт",
    "🧧": "ркт",
    "📦": "к",
    "🗳": "рк",
    "🕋": "миф",
    "💎": "кр",
    "🌌": "зв"
}

async def send_transfer_message1(client, chat_id, case_name, quantity):
    # Определение названия кейса для передачи
    case_alias = cases_list.get(case_name, "")
    # Сообщение о передаче
    transfer_message1 = f"Передать OLP_ZEPHYRmode {case_alias} {quantity}"
    await client.send_message(chat_id, transfer_message1)
    # Задержка 
    await asyncio.sleep(3)
async def send_transfer_messages1(client, event):
    # Определение id чата
    chat_id = '@mine_evo_bot'
    # Сообщение которое будет проверяться 
    message = event.raw_text
    lines = message.split("\n")
    # Обработка сообщения и отправка
    for line in lines:
        for case in cases_list:
            if case in line:
                item = line.split("шт.")
                if len(item) >= 2:
                    item = item[0].split(":")
                    if len(item) >= 2:
                        item = item[1].strip()
                        await send_transfer_message1(client, chat_id, case, item)

async def send_transfer_message2(client, chat_id, case_name, quantity):
    # Определение названия кейса для передачи
    case_alias = cases_list.get(case_name, "")
    # Сообщение о передаче
    transfer_message2 = f"Передать Reinu_olp {case_alias} {quantity}"
    await client.send_message(chat_id, transfer_message2)
    # Задержка 
    await asyncio.sleep(3)
async def send_transfer_messages2(client, event):
    # Определение id чата
    chat_id = '@mine_evo_bot'
    # Сообщение которое будет проверяться 
    message = event.raw_text
    lines = message.split("\n")
    # Обработка сообщения и отправка
    for line in lines:
        for case in cases_list:
            if case in line:
                item = line.split("шт.")
                if len(item) >= 2:
                    item = item[0].split(":")
                    if len(item) >= 2:
                        item = item[1].strip()
                        await send_transfer_message2(client, chat_id, case, item)

# Определение функции обработчика входящих сообщений1
for i, client in enumerate(clients1):
    @client.on(events.NewMessage)
    async def handle_incoming_message(event, client=client):
        for player_name in player_names1:
            if f"📦 Кейсы игрока\n{player_name}" in event.raw_text:
                await asyncio.sleep(2)
                await send_transfer_messages1(client, event)

# Определение функции обработчика входящих сообщений2
for i, client in enumerate(clients2):
    @client.on(events.NewMessage)
    async def handle_incoming_message(event, client=client):
        for player_name in player_names2:
            if f"📦 Кейсы игрока\n{player_name}" in event.raw_text:
                await asyncio.sleep(2)
                await send_transfer_messages2(client, event)

# Функция определения времени работы скрипта
def get_elapsed_time():
    current_time = datetime.datetime.now()
    elapsed_time = current_time - start_time
    elapsed_time_str = str(elapsed_time).split('.')[0]  # Отсекаем миллисекунды
    return elapsed_time_str

@client001.on(events.NewMessage(pattern='m.info'))
async def get_info1(event):
    global count1
    global cycles1
    elapsed_time_str = get_elapsed_time()
    # Определение id чата
    chat_id = event.chat_id
    # Отправка сообщения с информацией о количестве отправленных сообщений
    await send_message(client001, chat_id, f'🧑‍💻 ScriptInfo\n\n👥 Аккаунтов работает: ∞\n📨 Отправлено сообщений: {count1}\n🌀 Пройдено циклов: {cycles1}\n⌛ Время работы скрипта: {elapsed_time_str}')

@client01.on(events.NewMessage(pattern='m.info'))
async def get_info2(event):
    global count2
    global cycles2
    elapsed_time_str = get_elapsed_time()
    # Определение id чата
    chat_id = event.chat_id
    # Отправка сообщения с информацией о количестве отправленных сообщений
    await send_message(client01, chat_id, f'🧑‍💻 ScriptInfo\n\n👥 Аккаунтов работает: 4\n📨 Отправлено сообщений: {count2}\n🌀 Пройдено циклов: {cycles2}\n⌛ Время работы скрипта: {elapsed_time_str}')

# Промо-Коды
@client001.on(events.NewMessage(chats=[mineEvo_channel, my_channel]))  
async def process_new_message(event):
    # Сообщение которое будет проверяться 
    message = event.message
    if 'Промо' in message.message:
        promo_code = message.message.split('Промо ')[1].split()[0]
        for client in clients3:
            await client(SendMessageRequest(mine_evo, f'промо {promo_code}'))

for client in clients3:
    try:
        client.run_until_disconnected()
    except KeyboardInterrupt:
        pass
    finally:
        client.disconnect()

